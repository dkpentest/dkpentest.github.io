<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Large_website_architecture_sniffing | drunk for pentest</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
		
</head>
<body class="body kind-page">
	<header class="header">
	<a class="logo" href="/">drunk for pentest</a>
	
</header>
	<div class="primary">
	
	<main class="main">
		
		<div class="single block">
			<article class="entry">
				<h1 class="entry__title">Large_website_architecture_sniffing</h1>
				<div class="entry__content"><h3 id="大型网站架构嗅探">大型网站架构嗅探</h3>
<p>大型网站架构不是设计出来的，是根据实际需求逐步演化出来的。</p>
<hr>
<p>阿里教授-李智慧</p>
<h4 id="第一篇-概述">第一篇 概述</h4>
<h5 id="0x1-架构演化">0x1 架构演化</h5>
<p>小型网站一般只需要一台服务器，包含：</p>
<pre tabindex="0"><code>应用程序 - 文件 - 数据库

即，便宜又好用的 LAMP：
&#39;PHP&#39; on &#39;Apache&#39; with &#39;MySQL&#39; on linux
</code></pre><p>用户逐渐增加后，应用与数据分离，变成三台服务器</p>
<pre tabindex="0"><code>应用服务器 - 需要高性能CPU
文件服务器 - 需要大硬盘容量
数据服务器 - 需要大硬盘和大内存
</code></pre><p>用户进一步增加，需要引入高频数据的缓存机制</p>
<pre tabindex="0"><code>应用服务器 - 需要高性能CPU
    分布式缓存服务器（redis）
文件服务器 - 需要大硬盘容量
数据服务器 - 需要大硬盘和大内存
</code></pre><p>用户再增加，需要引入应用服务集群和负载均衡</p>
<pre tabindex="0"><code>负载均衡调度服务器
    应用服务集群
        分布式缓存服务器（redis）
文件服务器 - 需要大硬盘容量
数据服务器 - 需要大硬盘和大内存
</code></pre><p>用户再增加，需要数据库读写分离</p>
<pre tabindex="0"><code>负载均衡调度服务器
    应用服务集群
        分布式缓存服务器（redis）
    数据访问模块
文件服务器 - 需要大硬盘容量
    主数据服务器 - 写操作，主从同步操作
    从数据服务器 - 读操作
</code></pre><p>用户再增加，需要引入CDN和反向代理</p>
<pre tabindex="0"><code>CDN服务器（部署在运营商机房）
反向代理服务器（不熟在网站的中心机房）
    负载均衡调度服务器
        应用服务集群
            分布式缓存服务器（redis）
    数据访问模块
文件服务器 - 需要大硬盘容量
    主数据服务器 - 写操作，主从同步操作
    从数据服务器 - 读操作
</code></pre><p>用户再增加，数据库业务拆分已经不能满足要求，需要引入分布式数据库和文件系统</p>
<pre tabindex="0"><code>CDN服务器（部署在运营商机房）
反向代理服务器（不熟在网站的中心机房）
    负载均衡调度服务器
        应用服务集群
            统一数据访问模块
                分布式缓存服务器（redis）
                分布式文件服务器集群
                分布式数据服务器集群
</code></pre><p>用户再增加，需要引入其他类型的专门数据库，如ES搜索引擎、NoSQL</p>
<pre tabindex="0"><code>CDN服务器（部署在运营商机房）
反向代理服务器（不熟在网站的中心机房）
    负载均衡调度服务器
        应用服务集群
            统一数据访问模块
                分布式缓存服务器（redis）
                分布式文件服务器集群
                分布式数据服务器集群
                ES搜索引擎
                NoSQL
</code></pre><p>用户再增加，需要进行业务拆分，不同应用分给不同产品线，通过消息队列（Kafka）互相联系</p>
<pre tabindex="0"><code>CDN服务器（部署在运营商机房）
反向代理服务器（不熟在网站的中心机房）
    负载均衡调度服务器
        应用服务集群A
            消息队列Kafka
        应用服务集群B
            统一数据访问模块
                分布式缓存服务器（redis）
                分布式文件服务器集群
                分布式数据服务器集群
                ES搜索引擎
                NoSQL
</code></pre><p>用再增加，如果一万个应用都直连一万个数据库，那就是一亿个连接
需要引入分布式服务，把同样的事务交给可服用的分布式服务器</p>
<pre tabindex="0"><code>CDN服务器（部署在运营商机房）
反向代理服务器（也叫应用层负载均衡，部署在网站的中心机房）
    负载均衡调度服务器
        A应用服务集群
            消息队列Kafka
        B应用服务集群
            分布式服务器集群
                本地缓存
                统一数据访问模块
                    分布式缓存服务器（Memcached）
                    分布式文件服务器集群
                    分布式数据服务器集群
                    ES搜索引擎
                    NoSQL（如HBase）
</code></pre><p>至此，自然生长出的架构，开始把冗余的计算资源整合出售给中小公司，实现了云计算</p>
<p>网站的价值是能给用户做什么，不是怎么做的，因此没必要一开始就追求架构，舍本求末。
是业务成就了技术，事业成就了人，而不是反过来。技术是为业务而存在的，除此之外毫无意义。
技术是用来解决业务问题的，而业务问题，也可以用业务方式去解决。</p>
<h5 id="0x2-架构模式">0x2 架构模式</h5>
<p>我们的生活中充满了千篇一律的人生架构模式，考大学找工作成家立业重复
但是精彩的人生绝不会来源于复制</p>
<p>几种架构模式：</p>
<pre tabindex="0"><code>分层架构（横向划分业务）
    应用层(视图层、业务逻辑层) -&gt; 服务层(接口层、逻辑层) -&gt; 数据层
        禁止跨层调用和反向调用

分割架构（纵向划分业务）

分布式架构（把横纵切割的模块放在不同服务器上，性能增强，同时风险也变大）如 Hadoop 和他的 MapReduce计算框架，移动计算而不移动数据
    分布式应用和服务
    分布式静态资源
    分布式数据和存储

集群
缓存
    CDN、反向代理、本地缓存、分布式缓存
异步
    消息队列
冗余
自动化
安全
</code></pre><p>早期的 MPSS 架构（multiport single server 单服务多端口）：
在每一台服务器上部署多个服务，每个服务不同端口</p>
<p>现在通常是先虚拟化硬件设备，然后每个虚拟机部署的服务使用相同端口</p>
<p>多级缓存策略、多级安全策略（垃圾内容、僵尸粉）</p>
<h5 id="0x3-核心架构要素">0x3 核心架构要素</h5>
<p>架构的定义：</p>
<pre tabindex="0"><code>wiki版：有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的设计

通俗版：最高层次的规划，难以改变的决定
</code></pre><p>架构的五要素：
性能、可用性、伸缩性、扩展性、安全性</p>
<p>架构4+1视图：
逻辑视图、开发视图、处理视图、物理视图、场景视图</p>
<h4 id="第二篇-架构">第二篇 架构</h4>
<h5 id="0x4-高性能架构-瞬时响应">0x4 高性能架构-瞬时响应</h5>
<p>吞吐量：
TPS（每秒事务数）
HPS（每秒HTTP请求数）
QPS（每秒查询数）</p>
<p>网站性能优化是后端架构师非常关注的东西，可以从各个环节入手，但是我不太关心。</p>
<h5 id="0x5-高可用架构-万无一失">0x5 高可用架构-万无一失</h5>
<p>俗称的
2个9，基本可用
3个9，较高可用
4个9，有自动恢复能力的高可用，即一年99.99%时间可用（每年宕机53分钟）
5个9，极高可用，就是一年宕机5分钟</p>
<p>通常对工程师很重要，直接跟绩效奖金挂钩。宕机对品牌和效益产生直接影响</p>
<p>（升级发布）宕机高可用：</p>
<ul>
<li>无状态的访问，可以用负载均衡起到宕机高可用</li>
<li>有状态的访问（session），需要考虑session转移
早期的C/S架构会把session写在cookie里
后来的解决方案是，所有应用服务器共享一个session服务器</li>
</ul>
<p>保证服务高可用的几种方法：</p>
<ul>
<li>分级管理：核心服务拥有更好的软硬条件</li>
<li>超时设置</li>
<li>异步调用</li>
<li>服务降级</li>
<li>幂等性设计：一个服务调用一次和多次，结果是一样的（如付款）</li>
</ul>
<p>数据高可用：</p>
<ul>
<li>数据持久性：多个备份</li>
<li>数据可访问性</li>
<li>数据一致性：为满足高伸缩扩张和高可用，需要牺牲一致性</li>
</ul>
<p>灰度发布，也叫AB测试</p>
<h5 id="0x6-伸缩性架构-永无止境">0x6 伸缩性架构-永无止境</h5>
<p>不需要改变软硬条件，只需要改变服务器数量就能扩大或者缩小网站处理能力</p>
<p>纵向分离（分层后分离）
横向分离（业务分割后分离）</p>
<p>负载均衡的可伸缩性</p>
<ul>
<li>HTTP重定向负载均衡（容易被SEO判定作弊降级）</li>
<li>DNS负载均衡（通常作为一级负载均衡，分发给二级负载均衡处理器）</li>
<li>反向代理负载均衡</li>
<li>IP负载均衡</li>
<li>数据链路层负载均衡，也叫DR（直接路由）方式
（这种三角传输方式是目前使用最广泛的模式）</li>
</ul>
<p>关系型数据库的可伸缩性</p>
<ul>
<li>主从复制（写主，读从）</li>
<li>分库</li>
<li>分布式分片（一张表分成多个片存到多个库）
（目前最广泛的是 Apache HBase，专为可伸缩HDFS分布式存储设计）</li>
</ul>
<p>高手定律：高手之所以是高手，因为他遇到了常人不会遇到的问题。
没有救世主定律：遇到问题、分析问题、最后总能解决问题。单靠从外面挖人是解决不了问题的。</p>
<h5 id="0x7-可扩展架构-随需应变">0x7 可扩展架构-随需应变</h5>
<p>可伸缩性：通过增加减少自身资源规模，增加减少计算事务的能力。
可扩展性：对现有系统影响最小的情况下，扩展功能的能力。体现在低耦合</p>
<p>架构设计开闭原则（对扩展开放，对修改关闭）：考虑未来功能扩展，不需要修改现有的结构或代码</p>
<p>最好的低耦合方式是，没有直接调用
事件驱动架构（event driven architecture）：通过在低耦合的模块之间传递消息，以保持模块的松散耦合。</p>
<ul>
<li>该模式在OS中的应用是：生产者消费者模式</li>
<li>在大型网站架构中：分布式消息队列</li>
</ul>
<h5 id="0x8-安全架构-固若金汤">0x8 安全架构-固若金汤</h5>
<p>开放 API 三种形式</p>
<ul>
<li>RESTFul</li>
<li>webservice</li>
<li>RPC</li>
</ul>
<p>信息过滤</p>
<ul>
<li>敏感词过滤：先做信息过滤_ ，再用哈希表代替正则（查询效率高）</li>
<li>内容审核：采用分类算法
朴素贝叶斯（算法简单、速度快）
TAN算法
ARCS算法</li>
<li>黑名单：同样使用哈希表，但是考虑到内存太大可以使用布隆过滤器</li>
</ul>
<p>风控</p>
<ul>
<li>规则引擎</li>
<li>统计模型</li>
</ul>
<h4 id="第三篇-案例">第三篇 案例</h4>
<h5 id="0x9-淘宝">0x9 淘宝</h5>
<p>最早的淘宝 2003 年也就是 LAMP：
一个负载均衡，三个Apache+PHP应用服务器，三个主从MySQL</p>
<p>淘宝从LAMP，到昂贵的Oracle+IBM+ECM，再回到开源软件，根本动力：
不得已（商业需要）</p>
<h5 id="0x10-wiki">0x10 wiki</h5>
<h5 id="0x11-分布式存储doris">0x11 分布式存储Doris</h5>
<h5 id="0x12-网购秒杀">0x12 网购秒杀</h5>
<h5 id="0x13-故障案例">0x13 故障案例</h5>
<h4 id="第四篇-架构师">第四篇 架构师</h4>
<h5 id="0x14-架构师领导艺术">0x14 架构师领导艺术</h5>
<h5 id="0x15-网站架构师职场攻略">0x15 网站架构师职场攻略</h5>
<h5 id="0x16-漫话网站架构师">0x16 漫话网站架构师</h5>
<p>web开发技术演进：</p>
<ul>
<li>CGI：擅长处理响应</li>
<li>服务器页面（如PHP）：擅长构造响应页面</li>
<li>MVC架构：二者结合</li>
</ul></div>
				
			</article>
		</div>
	</main>
	
	



	

	</div>
	<footer class="footer">
	<div class="footer__copyright">© 2024 drunk for pentest. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
</body>
</html>