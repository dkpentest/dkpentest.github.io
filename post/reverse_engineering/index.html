<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Reverse_engineering | drunk for pentest</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
		
</head>
<body class="body kind-page">
	<header class="header">
	<a class="logo" href="/">drunk for pentest</a>
	
</header>
	<div class="primary">
	
	<main class="main">
		
		<div class="single block">
			<article class="entry">
				<h1 class="entry__title">Reverse_engineering</h1>
				<div class="entry__content"><h3 id="逆向工程">逆向工程</h3>
<hr>
<h5 id="编译过程">编译过程</h5>
<p>linux下默认编译器是GCC（那种在一个平台编译另一个平台可执行文件的行为叫“交叉编译”）</p>
<pre tabindex="0"><code>gcc hello.c -o hello -save-temps --verbose
//编译选项 -save-temps 保存过程文件，--verbose显示详细工作流程
</code></pre><p>编译过程五个步骤
1、词法分析
2、语法分析
3、语义分析
4、中间代码生成和优化
5、代码生成和优化</p>
<p>GCC编译四个阶段
cc1编译器参与
1、预处理 preprocess - 生成 hello.i</p>
<pre tabindex="0"><code>gcc -E hello.c -o hello.i
//递归处理 #include，删除所有#define、#if等预处理指令，删除所有注释，添加行号
</code></pre><p>2、编译 compile - 生成汇编 hello.s</p>
<pre tabindex="0"><code>gcc -S hello.i -o hello.s -masm=intel -fno-asynchronous-unwind-tables //加一些编译参数
</code></pre><p>as汇编器参与<br>
3、汇编 assemble - 生成对象文件 hello.o (object file)
链接器collect2（其实是ld命令封装）参与（将一系列C语言运行时库CRT中的目标文件.o和一系列动态链接库.so链接到可执行hello）</p>
<pre tabindex="0"><code>这里 hello.o 是可重定位文件  
</code></pre><p>4、链接 link - 链接libc.a 生成可执行文件 hello</p>
<pre tabindex="0"><code>这里 hello 是静态链接的可执行文件，包含大量库文件  
</code></pre><hr>
<h5 id="elf文件格式">ELF文件格式</h5>
<p>ELF文件格式（可执行可链接格式），是COFF（common file format）格式的变种，定义在 /usr/include/elf.h 里</p>
<p>目标文件三个半种形式：</p>
<ul>
<li>.exec 经过链接的可执行文件</li>
<li>.rel 可重定位文件，即.o</li>
<li>.dyn 动态链接库文件，可以运行时加载</li>
<li>还有一种定位内核崩溃的 core dump file</li>
</ul>
<p>目标文件的两种视角：</p>
<pre tabindex="0"><code>- 链接视角：
    ELF header //可用魔术字 7f 45 4c 46 即 \177ELF 定位
    program header table (opntional)
    section ... // 至少包括 .text .data .bss
    Section header table
- 运行视角
    ELF header
    Program header table
    Segment ...
    Section header table (opntional)
</code></pre><hr>
<h5 id="一些工具">一些工具</h5>
<ul>
<li>GNU utils 使用方法</li>
</ul>
<pre tabindex="0"><code>安装：brew install binutils //在 /usr/local/opt/binutils/bin
（brew install coreutils //这样是安装一揽子工具）
readelf -h hello.rel //这里mac自带gcc编出来的ELF，魔术字是不一样的 0xfeedfacf
readelf -h hello.rel //section表
objdump -x -s -d hello.rel 
</code></pre><ul>
<li>
<p>radare2</p>
</li>
<li>
<p>IDA</p>
</li>
</ul>
<hr>
<h5 id="内存管理">内存管理</h5>
<p>除了一些特殊的软件平台（如office，有自己私有的内存管理方法），</p></div>
				
			</article>
		</div>
	</main>
	
	



	

	</div>
	<footer class="footer">
	<div class="footer__copyright">© 2024 drunk for pentest. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
</body>
</html>