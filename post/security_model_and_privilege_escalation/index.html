<!DOCTYPE html>
<html class="no-js" lang="en-us">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Security_Model_and_Privilege_Escalation | drunk for pentest</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<link rel="stylesheet" href="/css/bundle.css">
	<link rel="icon" href="/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="/icons/32.png" sizes="32x32" type="image/png">
		
</head>
<body class="body kind-page">
	<header class="header">
	<a class="logo" href="/">drunk for pentest</a>
	
</header>
	<div class="primary">
	
	<main class="main">
		
		<div class="single block">
			<article class="entry">
				<h1 class="entry__title">Security_Model_and_Privilege_Escalation</h1>
				<div class="entry__content"><h3 id="安全模型理论与权限提升">安全模型理论与权限提升</h3>
<p>云、网络、平台、系统的入侵过程中，提权都是绕不开的关键环节。本篇从安全模型理论出发，试图探讨权限提升的本质。</p>
<hr>
<h4 id="0x0-安全模型理论">0x0 安全模型理论</h4>
<p>安全模型按照使用场景不同、分类维度不同，至少可以分为以下几类：</p>
<p>1、访问控制模型：如何控制用户对资源的访问</p>
<pre tabindex="0"><code>- 自主访问控制（DAC，Discretionary Access Control）：
用户可以自主控制其拥有的资源的访问权限。访问决策基于资源拥有者的意愿。linux的权限体系正式基于此，后面从进程管理角度详细展开

- 强制访问控制（MAC，Mandatory Access Control）：
访问决策由系统策略确定，资源拥有者不能自由更改访问权限。通常用于高度保密的环境，如军事系统。也作为linux DAC模型的补充，如linux的LSM机制（SELinux、AppArmor）、windows的强制完整性控制、mac的SIP机制等

- 基于角色的访问控制（RBAC，Role-Based Access Control）：
访问权限基于用户角色。角色代表一组与特定职责相关的权限。通常用于各种企业平台系统的权限管理，可以解决用户与权限点之间的熵增问题

- 基于属性的访问控制（ABAC，Attribute-Based Access Control）：访问控制基于用户、资源和环境的属性。属性可以是静态的（如用户的职位）或动态的（如当前时间）。通常用于各种云，让大量的变更操作通过修改属性配置实现自动化管理
</code></pre><p>2、信息流模型：关注数据在系统中的传输和处理过程中的保密性</p>
<pre tabindex="0"><code>- 贝尔-拉帕杜拉模型（Bell-LaPadula Model）：这是一个用于保护数据机密性的模型。它使用安全等级和访问控制矩阵来限制信息的流动。
向下读，向上写：
    * 简单安全性属性规则（Simple Security Property，也称为“不读高于己”的原则）：一个实体只能访问等于或低于其安全等级的数据对象
    * 属性规则（Star Property，也称为“不写低于己”的原则）：一个实体只能向等于或高于其安全等级的数据对象写入数据

- 比伯模型（Biba Model）：与贝尔-拉帕杜拉模型相反，比伯模型主要关注数据的完整性。它通过限制数据流来保护数据免受未经授权的修改
向上读，向下写：
    * 简单完整性属性规则（Simple Integrity Property，也称为“不读低于己”的原则）：一个实体只能访问等于或高于其安全等级的数据对象
    * 完整性属性规则（Star Integrity Property，也称为“不写高于己”的原则）：一个实体只能向等于或低于其安全等级的数据对象写入数据
</code></pre><p>3、安全状态机模型</p>
<pre tabindex="0"><code>这类模型使用状态机表示法来描述系统的安全状态和状态之间的转换。它们通常用于描述系统的安全属性和分析潜在的安全威胁。如bios引导安全启动过程中的打点机制。
</code></pre><p>4、安全生命周期模型</p>
<pre tabindex="0"><code>这类模型关注安全策略和控制在整个系统生命周期中的实施和管理。它们包括安全需求分析、设计、实施、测试、维护和废弃等阶段。主要参考场景是研效流程管理。
</code></pre><p>5、安全信任模型：关注系统中各个实体之间的信任关系</p>
<pre tabindex="0"><code>- 公钥基础设施（PKI，Public Key Infrastructure）：
PKI是一种基于非对称加密的信任模型，其中包括证书颁发机构（CA）和证书。CA负责验证实体的身份并颁发证书，证书中包含实体的公钥和其他身份信息。实体之间的信任是通过证书链和CA的信任来建立的。

- 信任管理框架（Trust Management Frameworks）：
信任管理框架提供了一种在分布式系统中建立和管理信任关系的方法。这类框架通常包括一组信任度量、信任建立机制和信任决策算法。例如，PGP（Pretty Good Privacy）是一种基于“Web of Trust”概念的信任管理框架，用户之间可以相互签名以建立信任关系。

- 社交信任模型（Social Trust Models）：
社交信任模型基于社交网络中的个体之间的信任关系。这类模型通常依赖于用户之间的直接或间接关系（如朋友、家人或同事）来评估信任度。一些在线社交网络（如Facebook和LinkedIn）采用社交信任模型来提供安全性和隐私保护。

- 基于声誉的信任模型（Reputation-Based Trust Models）：这类模型依赖于实体在过去的行为和其他实体的评价来评估信任度。基于声誉的信任模型常用于在线市场、P2P网络和在线社区等场景。
</code></pre><p>AAA服务概念：</p>
<pre tabindex="0"><code>身份验证 Authentication、授权 Authorization、审计 Accounting/Auditing，
AAA服务包含五个过程
    标识Identification 过程：声明身份（标识是公开信息）
    身份验证 过程：证实身份（如密码）
    授权 过程：对具体主体面向客体的访问许可（由访问控制模型来定义：自助访问控制DAC、强制访问控制MAC、角色访问控制RBAC）
    审计 过程：记录日志 
    记账Accounting（问责制） 过程：审查日志并问责，保证上述得到执行
</code></pre><p>多因子认证：</p>
<pre tabindex="0"><code>你知道的东西（密码、PIN）
你拥有的东西（令牌、智能卡）
你具备的东西（指纹、虹膜）
</code></pre><hr>
<h4 id="0x1-linux-uidgid机制">0x1 linux UID/GID机制</h4>
<p>linux系统中，所有操作的本质，都是“进程”访问“文件”，进程能不能访问文件，就靠DAC安全模型来控制（SELinux额外还有MAC）。再具体一点：linux通过用户、进程、文件的UID/GID来进行权限管理</p>
<p>一些重要文件：</p>
<pre tabindex="0"><code>/etc/passwd     保存用户信息
用户名: 口令（在 /etc/shadow 加密保存）：UID:GID（默认 UID）: 描述注释: 主目录: 登录 shell(第一个运行的程序)
例如：root:x:0:0:root:/root:/bin/bash

/etc/group      保存组信息
组名：口令（一般不存在组口令）：GID：组成员用户列表（逗号分割的用户 UID 列表）
例如：root:x:0

/etc/shadow     保存密码口令及其变动
登录名: 加密口令: 最后一次修改时间: 最小时间间隔: 最大时间间隔: 警告时间: 不活动时间:
</code></pre><p>一个用户属于一个UID，多个GID（其中默认必有一个与UID同名）</p>
<p>linux文件类型</p>
<pre tabindex="0"><code>普通文件（文本、二进制等）      可用 touch 创建
socket文件                  程序执行过程 创建
管道文件                     可用 mkfifo 创建
设备文件（字符文件、块文件）     可用 mknod 创建
软链接文件                    可用 ln 创建
</code></pre><p>常见指令参数</p>
<pre tabindex="0"><code>ls -l
r   读      1
w   写      2
x   执行    4
    s   可赋予文件属主权限的权限
    t   目录 stick-bit 粘滞位，有权限的只能修改自己的文件，没权限的可以修改所有文件
    s/t 权限需要追加124，如：chmod 1755 ./xxx
首字符类型：（如：-rwx-rx-rx-t)
普通文件 (-)、目录文件 (d)、套接字文件 (s)，管道文件 (p)，字符文件 (c)，块文件 (b)，链接文件 (l)
</code></pre><p>权限相关进程属性</p>
<pre tabindex="0"><code>euid    effective user id 进程访问文件权限相关的UID //可以被改变，核心
egid    effective gourp id 进程访问文件权限相关的GID
ruid    real user id 创建该进程的用户登陆时的UID //实际使用者
rgid    real gourp id 创建该进程的用户登陆时的GID
saved set user id：拷贝自euid //不会被改变
saved set group id：拷贝自egid
</code></pre><p>进程访问控制策略</p>
<pre tabindex="0"><code>exec（执行）一个可执行程序
- euid：一般为 ruid，可能会变 
    具体：如果可执行程序的权限位有s（比如 sudo rs-x-x，others先用第三个x获得第一个s从而拥有owner权限），进程exec后该进程 euid 被设置为可执行程序的 uid （即 root）、ssuid 拷贝自 
- ruid：一般不变
- ssuid：拷贝自euid

setuid（uid）修改权限属性
- superuser 可以修改全部（euid、ruid、ssuid）
- unprivileged user 只能在 euid == ruid 时修改 euid
</code></pre><hr>
<h4 id="0x2-提权原理">0x2 提权原理</h4>
<p>提权分纵向提权、横向提权</p></div>
				
			</article>
		</div>
	</main>
	
	



	

	</div>
	<footer class="footer">
	<div class="footer__copyright">© 2024 drunk for pentest. <span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span></div>
</footer>
</body>
</html>